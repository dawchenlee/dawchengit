#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon Jul 15 17:46:33 2019
题目：最长上升子序列
给定一个无序的整数数组，找到其中最长上升子序列的长度。
示例:
输入: [10,9,2,5,3,7,101,18]
输出: 4 
解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。
说明:
可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。
你算法的时间复杂度应该为 O(n2) 。
进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?

"""
### 动态规划解法
'''
方法一：动态规划
定义状态：dp[i]表示以第i个数字为结尾的最长上升子序列的长度。即在 [0, ..., i] 的范围内，
选择以数字nums[i]结尾可以获得的最长上升子序列的长度。注意：以第i个数字为结尾，即要求nums[i]
必须被选取。反正一个子序列一定会以一个数字结尾，那我就将状态这么定义，这一点是常见的。

状态转移方程：遍历到索引是i的数的时候，我们应该把索引是[0, ... ,i - 1]的dp都看一遍，如果
当前的数nums[i]严格大于之前的某个数，那么nums[i]就可以接在这个数后面形成一个更长的上升子序列。
把前面的i个数都看了，dp[i]就是它们的最大值加1。即比当前数要小的那些里头找最大的，然后加1 。
总结一下，状态转移方程是：
dp[i] = max{1 + dp[j] if j < i and nums[i] > nums[j]}
直接看下面的例子或者代码来理解这个状态转移方程。
最后不要忘记，扫描一遍这个 dp 数组，其中最大值的就是题目要求的最长上升子序列的长度。
'''
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
    # 此解法的时间复杂度为O(n2),空间复杂度为O(n)
    # 将 dp 数组定义为：以 nums[i] 结尾的最长上升子序列的长度
    # 那么题目要求的，就是这个 dp 数组中的最大者
    # 以数组  [10, 9, 2, 5, 3, 7, 101, 18] 为例
    # dp 的值： 1  1  1  2  2  3  4    4
        size = len(nums)
        # 特判
        if size <= 1:
            return size
        
        dp = [1] * size
        for i in range(1, size):
            for j in range(i):
                if nums[i] > nums[j]:
                    # + 1 的位置不要加错了
                    dp[i] = max(dp[i], dp[j] + 1)
        # 最后要全部一看遍，取最大值
        return max(dp)

### 贪心算法+二分查找
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        ## 此解法时间复杂度为O(nlogn),空间复杂度为O(n)
        if len(nums) < 2:
            return len(nums)
        aux = [nums[0]]

        for i in range(1,len(nums)):
            if nums[i] > aux[-1]:
                aux.append(nums[i])
                continue
            left = 0
            right = len(aux) - 1    
            while left < right:
                mid = (left + right) // 2
                if aux[mid] < nums[i]:
                    left = mid + 1
                else:
                    right= mid
            aux[left] = nums[i]
        return len(aux)

'''
算法的基本思想如下：
如果前面的数越小，后面接上一个随机数，就会有更大的可能性构成一个更长的“上升子序列”。

这个思想也不难理解，我们举例说明：如果前面的数是1，后面接上一个随机数，能够构成长度为2的
“上升子序列”的可能性，就远远大于前面的数是1000010000，后面接上一个随机数，能够构成长度为
2的“上升子序列”的可能性。

基于这个思想，我们先介绍算法的流程，然后再做总结，最后把其中关键的地方向大家指出。
算法的执行流程：
1、设置一个有序数组 aux，初始时为空；
数组命名为aux大家先不用纠结，只要先有个印象，反正有序数组aux不是“最长上升子序列”（下文还会强调)
，不能命名为LIS，有序数组tail是用于求解LIS问题的辅助数组，如果大家有更贴切的命名，可以在评论区向我指出。

2、在遍历数组nums的过程中，每来一个新数num，如果这个数（严格）大于有序数组aux的最后一个元素
就把num放在有序数组aux的后面，否则进入第3点；
注意：这里的大于是“严格大于”，不包括等于的情况。

3、在有序数组aux中查找第1个大于等于num的那个数，试图让它变小；
“试图让它变小”的含义是：如果在有序数组tail中查找第1个等于 num 的那个数，等于就没有办法让它变
小啦，这个企图失败；如果在有序数组aux中查找第1个（严格）大于num的那个数，就可以让它变小，企图成功；
在有序数组aux中找大于等于num的第1个数，可以使用“二分法”。

4、遍历新的数num，先尝试上述第2点，第2点行不通就执行第3点，直到遍历完整个数组nums，最终有序数组
aux的长度，就是所求的“最长上升子序列”的长度。

以上算法能够奏效的关键是：
根据最开始提到的“基本思想”，可以认为是一种“贪心选择”的思想：只要让前面的数尽量小，在算法的执行
过程中，第2点被执行的机会就更多。

'''